### access_log 풀이 ###
-> access_log는 웹 서버 로그임
-> 클라이언트 IP 주소 | 접속 요청 시간 | 요청 메소드.요청 페이지.요청 프로토콜 및 버전 | 응답 상태 코드 | 응답 바이트 크기 | 이전 페이지의 URL | 클라이언트의 브라우저 정보 ; 구성
-> 각 정보를 통해 모든 흔적을 의심할 수 있음. (즉, 공통된게 많다면 차이가 있는 것이 단서일 가능성 높음)
-> IP 주소에서 시간에 메소드를 이용해 페이지에 대해 프로토콜로 요청을 했음.
-> 해당 응답 코드는 이것이고, 이만큼의 바이트가 전송되었음.
-> 이전 페이지는 이것이고, 브라우저 정보는 이것임.
=> 해석은 위의 3줄 처럼 하면됨.

## 접근 ## 
STEP 1) notepad++로 연다.
STEP 2) flag를 검색해본다.
STEP 3) 차이점을 봐본다 (요청 부분과 응답 바이트 크기가 의심됨.)
* 요청 SQL 문은 GET/vulnerabilities/sqli/?id=1' AND 8487=IF((ORD(MID((SELECT IFNULL(CAST(COUNT(*) AS CHAR),0x20) FROM dvwa.flag),1,1))>790966),SLEEP(1),8487)-- Adyu&Submit=SubmitHTTP/1.1임
-> 해석하면 ..
1. 1'을 이용해 새로운 쿼리문을 만듦.
2. AND 8487 = 8487을 기대하고 있음.
3. MID를 통해 1번째에서 1개의 문자를 가져오려함 ()
-> MID는 SUBSTR, SUBSTRING과 동의어
4. IFNULL로 null일 경우 0x20을 반환하도록 함.
5. ORD로 숫자 반환함
6. IF문으로 790966보다 크면 1초 지연하고 아니면 8487 반환함.
-> 즉, 참이면 1초 지연하고 거짓이면 바로 응답 오도록함.

STEP 4) > 68, > 66에서 참이 될 후보는 67, 68임 (두개에서 응답 바이트가 다르게 나타남)
-> 플래그 형식은 DH이므로 68이 되어야 D가됨. (즉, 참이면 1600을 주고, 거짓이면 1800이상을 줌.)

STEP 5) 이후, 정규식을 통해 notepad++ 필터링함. 

dvwa.flag ORDER BY id LIMIT 0,1),\d{1,2},1))!=\d{2,3}
-> dvwa.flag 테이블에서 id 컬럼을 기준으로 정렬하고, 첫 번째 레코드만 선택하고, 1자리 또는 2자리 숫자와 매칭하고, 2자리 숫자 또는 3자리 숫자와 다른지 판단.

STEP 6) 아스키 문자를 변환해줌.

## 깨달은 점 ##
1. 파이썬 스크립트로 파싱해서 특정 키워드 위주로 가져왔으면 쉬웠음
2. !=이 있는 것이 flag였음 ()
3. SLEEP과 SQL이 같이 쓰이면 Time-Based SQL Injection 의심 (지연을 통해 참과 거짓을 통해 값을 추론 하는 것.)
4. MID 함수의 2번째 글자가 바뀔때 기준이 !=이므로 !=일때가 원하는 값을 찾은 것임.
5. 이를 바탕으로 스크립트 작성.

## 정확한 접근법 ##
STEP 1) 먼저 로그 파일을 열고, flag 검색
STEP 2) 해당 로그 URL 디코딩
STEP 3) SQL 문법 분석
STEP 4) 특징 발견
STEP 5) 스크립트 작성


























