### 휴지통 및 파일 복구 ###

## 들어가며 ##
-> 삭제된 파일을 복구하는 방법
-> 휴지통 아티팩트 볼 것임. (Windows 운영체제에서 파일을 삭제하면 휴지통으로 이동하기 때문에 ..)
-> 파일을 완전히 삭제하였을 때 NTFS 파일 시스템에서 어떻게 처리하는지와 어떻게 복구할 수 있는 지 볼 것임.

## 휴지통 ##

# Windows 파일 삭제 #
*파일을 삭제하는 방법
- 파일을 우클릭 후 삭제 버튼 누르기
- Delete 키를 눌러 파일 삭제
- 파일을 드래그해 휴지통 이동

-> Shift+Delete는 휴지통으로 이동하지 않고 완전 삭제됨. (사용자 입장에서는 복원이 불가능함) ; '완전 삭제'
-> $MFT의 해당 파일 엔트리에 삭제 표시가 추가됨. (flag가 삭제 표시되는 것 (0x00)).
-> 이 경우에도 데이터가 완전히 사라지는 것은 아니므로 복구 가능 (콘텐츠는 살아 있음)

# 휴지통 아티팩트 동작 원리 #
-> 삭제 버튼을 누르는 것은 파일을 삭제하는 것이 아니라 파일 경로를 휴지통 경로로 이동하는 것임 (엄밀히 말하자면 ..)

STEP1) cmd를 관리자 권한으로 실행하기
STEP2) dir /a로 사용자 계정의 휴지통으로 이동
STEP3) 삭제된 파일은 $R{문자열 6자리}.{확장자} 와 $I{문자열 6자리}.{확장자} 형태로 휴지통에 저장

*$R 파일은 원본 파일과 완전히 동일한 데이터를 가지지만 이름반 변경된 형태로 휴지통에 저장
*$I 파일은 원본 파일의 이름을 포함한 메타 데이터를 가짐

-> 휴지통에서 데이터를 삭제하면 $R, $I 파일이 생성됨
-> 휴지통에서 데이터를 복원하면 $R 파일이 원래 위치로 돌아감
-> 휴지통 비우기 수행하면 $R, $I가 모두 있는 데이터만 삭제됨.

"휴지통 완전 비우기를 하였을 때 $R 파일과 짝을 이루지 못한 $I 파일은 삭제되지 않음"
"$I 파일은 원본 파일의 경로, 파일이 삭제된 시간 등 메타데이터를 담고 있어서 삭제된 파일의 흔적을 획득 가능함."

# 휴지통 아티팩트 수집 #
-> C:\$Recycle.Bin\SID 경로에 휴지통 아티팩트 존재. (S-1-5 문자열이 사용자 계정을 나타내는 SID임.)
-> 휴지통을 분석할 때는 cmd나 FTK Imager로 별도 추출 분석하는 것이 좋음 

* FTK Imager에서 $Recycle.BIN\S-...에 있는 파일 전체를 선택해 추출해야됨. (특수 설정 때문에 디렉터리로 추출 시 파일이 보이지 않음)

# 휴지통 아티팩트 분석 #
-> $R의 경우 원본과 동일하므로 $I 파일 구조만 분석하면됨
- 0x0-0x7: 시그니처
- 0x8-0xF: 원본 파일의 크기
- 0x10-0x17: 파일이 삭제된 시간
- 0x18-0x1B: 원본 파일 경로 길이
- 0x1C 이후: 원본 파일 경로

-> 분석 도구: RBCmd (-d: 디렉토리 전체 입력 값, -f: 단일 파일을 입력 값)

## 파일 복구 기법 ##

# 파일 삭제 방식 #
-> $LogFile을 분석해보면, 파일 삭제가 정말로 휴지통으로 이동한 것임을 알 수 있음. (휴지통으로의 '삭제': 폴더 이동과 동일하게 로그가 남음)

Q) Shift+Delete는 어떻게 작동할까?
-> 모든 파일이나 폴더는 NTFS 파일 시스템에서 하나의 MFT 엔트리를 가짐.
-> 이러한 MFT 엔트리들이 모여있는 곳이 $MFT임.
-> Shift+Delete는 MFT 엔트리를 삭제하는 방식으로 동작함.
-> 원래는 MFT 엔트리를 보고 파일의 존재 유무를 알 수 있는데, 이게 삭제되면 파일의 유무를 알 수 없게 되어서 시스템에서는 삭제 되었다고 하는 것임.
-> 파일 콘텐츠는 삭제되지 않음.

# 파일 삭제 실습 #
-> D드라이브에서 $DATA 영역이 Non-Resident가 되도록 700 Byte 이상 데이터를 작성해줌.
-> 이후 관리자 권한으로 HxD를 열음.

STEP 1) MFT 시작 주소를 찾음: Ex) 0xC0000 * 0x1000 (클러스터 크기) = 0xC0000000
STEP 2) 이후, 검색 기능을 통해 파일 이름을 검색해줌. (MFT 엔트리에서 파일 이름은 유니코드 방식으로 저장됨.)
STEP 3) 이후 $DATA 영역의 Cluster Run 구조 발견해줌. (속성ID: 0x80, 그로부터 0x40 오프셋 뒤에 Cluster Run 구조 위치.)
STEP 4) 0x21028811로 저장되어 있다면 .. Cluster Offset: Ex) 0x1188 * 0x1000 (클러스터 크기) | Cluster Length: Ex) 0x2: 2개 클러스터만큼 파일 존재 (0x2000만큼)
STEP 5) 이제부터 MFT 엔트리 오프셋(MFT 시작 주소)과 파일 오프셋 (Cluster Offset)을 기억하고, 파일을 삭제한 후 해당 오프셋의 데이터가 어떻게 변하는 지 확인.
STEP 6) Shift + Delete 수행
STEP 7) MFT Entry는 Flag 영역이 0x00으로 변해있음 (삭제된 것), 데이터 오프셋에는 데이터가 그대로 존재

"즉, 디지털 포렌식 관점에서는 삭제된 파일도 복구가 가능하다."
-> FTK Imager로 해당 볼륨 열어보면 완전 삭제했어도 파일 복구가 가능함 !

# 파일 복구 한계 #
-> 모든 파일을 복구할 수는 없음.
-> 파일 시스템은 다른 파일이나 폴더가 생길 때 Flag가 삭제 처리된 MFT 엔트리와, MFT 엔트리에서 비할당처리된 데이터 영역은 덮어써짐.
-> 이동식 저장장치 경우 비교적 파일 복구가 쉬움

## 파일 카빙 기법 ##
-> 카빙: 물건을 깎아서 조각하거나 글씨를 새기는 행위

# 파일 카빙 #
-> 파일시스템 메타데이터가 없을 때에도 파일 조각을 모아서 파일을 재조합하는 과정.
-> 파일 시그니처 기반 카빙, 파일 구조 기반 카빙이 있음.

# 파일 시그니처 기반 카빙 #
-> 헤더와 푸터 정보를 이용한다.
-> 헤더부터 푸터까지 잘라내어 하나의 파일을 만들어 내느 방법.
-> Python Script를 통해 파일 시그니처 기반 카빙 가능. (Ex. PNG 파일) ; 내일 와서 실습해보기 (1월 14일에 실습 !)

# 파일 구조 기반 카빙 #
-> 파일 구조를 기반으로 파일의 시작 위치와 끝 위치를 정확하게 판단하여 카빙
-> 시그니처가 중간에 나타나거나, 헤더만 있는 경우가 있어. 파일 구조에 기반해야할 때 사용.

* exe 파일 카빙 로직
STEP 1) PE 헤더 시그니처(MZ) 찾고, DOS Header 구조를 통해 NT Header 시작 위치를 찾는다.
STEP 2) NT Header 시그니처(PE) 확인하고, File Header에서 Section 갯수, Optional Header에서 PE Header의 전체 크기 확인하여 Section의 헤더 위치 구한다.
STEP 3) 각각의 Section Header에서 Section의 크기 파악.
STEP 4) PE Header의 크기와 각 Section의 크기를 더해 PE 파일의 크기 계산
STEP 5) PE 헤더 시그니처로부터 해당 크기만큼 잘라내어 가져온다.

-> binwalk나 bulk_extractor와 같은 도구 이용됨.

## 마무리 ##

















































